#!/usr/bin/env tsx
import fs from 'node:fs'
import path from 'node:path'
import { loadEnabledModules, moduleFsRoots, moduleImportBase } from './shared/modules-config'

type GroupKey = '@app' | '@open-mercato/core' | '@open-mercato/example' | string

const OUT_CONSOLIDATED = path.resolve('generated/entities.ids.generated.ts')

function toVar(s: string) { return s.replace(/[^a-zA-Z0-9_]/g, '_') }
function toSnake(s: string) { return s.replace(/([a-z0-9])([A-Z])/g, '$1_$2').replace(/\W+/g, '_').replace(/_{2,}/g, '_').replace(/^_+|_+$/g, '').toLowerCase() }

function pkgModulesRootFor(from?: string) {
  if (!from || from === '@open-mercato/core') return path.resolve('packages/core/src/modules')
  const m = from.match(/^@open-mercato\/(.+)$/)
  if (m) return path.resolve(`packages/${m[1]}/src/modules`)
  // Unknown source: default to core
  return path.resolve('packages/core/src/modules')
}

function pkgRootFor(from?: string) {
  if (!from || from === '@open-mercato/core') return path.resolve('packages/core')
  const m = from.match(/^@open-mercato\/(.+)$/)
  if (m) return path.resolve(`packages/${m[1]}`)
  return path.resolve('packages/core')
}

function ensureDir(p: string) { fs.mkdirSync(path.dirname(p), { recursive: true }) }

async function scan() {
  const entries = loadEnabledModules()

  const consolidated: Record<string, any> = {}
  const grouped: Record<GroupKey, Record<string, any>> = {}
  const modulesDict: Record<string, string> = {}
  const groupedModulesDict: Record<GroupKey, Record<string, string>> = {}

  for (const entry of entries) {
    const modId = entry.id
    const roots = moduleFsRoots(entry)
    const imps = moduleImportBase(entry)
    const group: GroupKey = (entry.from as GroupKey) || '@open-mercato/core'

    // Locate entities definition file (prefer app override)
    const appData = path.join(roots.appBase, 'data')
    const pkgData = path.join(roots.pkgBase, 'data')
    const appDb = path.join(roots.appBase, 'db')
    const pkgDb = path.join(roots.pkgBase, 'db')
    const bases = [appData, pkgData, appDb, pkgDb]
    const candidates = ['entities.override.ts', 'entities.ts', 'schema.ts']
    let importPath: string | null = null
    for (const base of bases) {
      for (const f of candidates) {
        const p = path.join(base, f)
        if (fs.existsSync(p)) {
          const fromApp = base.startsWith(roots.appBase)
          const sub = path.basename(base) // 'data' | 'db'
          importPath = `${fromApp ? imps.appBase : imps.pkgBase}/${sub}/${f.replace(/\.ts$/, '')}`
          break
        }
      }
      if (importPath) break
    }
    // No entities file found â†’ still register module id
    if (!importPath) {
      modulesDict[modId] = modId
      groupedModulesDict[group] = groupedModulesDict[group] || {}
      groupedModulesDict[group]![modId] = modId
      continue
    }

    // Dynamically import the entities module to list exported classes
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const mod = await import(importPath)
    const exportNames = Object.keys(mod)
    const entityNames = exportNames
      .filter((k) => typeof (mod as any)[k] === 'function')
      .map((k) => toSnake(k))
      .filter((k, idx, arr) => arr.indexOf(k) === idx)

    // Build dictionaries
    modulesDict[modId] = modId
    groupedModulesDict[group] = groupedModulesDict[group] || {}
    groupedModulesDict[group]![modId] = modId

    consolidated[modId] = consolidated[modId] || {}
    grouped[group] = grouped[group] || {}
    ;(grouped[group] as any)[modId] = (grouped[group] as any)[modId] || {}
    for (const en of entityNames) {
      consolidated[modId][en] = `${modId}:${en}`
      ;(grouped[group] as any)[modId][en] = `${modId}:${en}`
    }
  }

  // Write consolidated output
  const consolidatedSrc = `// AUTO-GENERATED by scripts/generate-entity-ids.ts
export const M = ${JSON.stringify(modulesDict, null, 2)} as const
export const E = ${JSON.stringify(consolidated, null, 2)} as const
export type KnownModuleId = keyof typeof M
export type KnownEntities = typeof E
`
  ensureDir(OUT_CONSOLIDATED)
  fs.writeFileSync(OUT_CONSOLIDATED, consolidatedSrc)

  // Write per-group outputs
  const groups = Object.keys(grouped) as GroupKey[]
  for (const g of groups) {
    const isApp = g === '@app'
    const out = isApp
      ? path.resolve('generated/entities.ids.generated.ts')
      : path.join(pkgRootFor(g), 'generated', 'entities.ids.generated.ts')
    const src = `// AUTO-GENERATED by scripts/generate-entity-ids.ts
export const M = ${JSON.stringify(groupedModulesDict[g] || {}, null, 2)} as const
export const E = ${JSON.stringify(grouped[g] || {}, null, 2)} as const
export type KnownModuleId = keyof typeof M
export type KnownEntities = typeof E
`
    ensureDir(out)
    fs.writeFileSync(out, src)
  }
}

scan().then(() => {
  console.log('Generated', path.relative(process.cwd(), OUT_CONSOLIDATED))
}).catch((e) => {
  console.error('Failed to generate entity ids:', e)
  process.exit(1)
})
