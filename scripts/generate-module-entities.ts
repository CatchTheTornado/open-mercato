#!/usr/bin/env tsx
import fs from 'node:fs'
import path from 'node:path'

const modulesRoot = path.resolve('src/modules')
const outFile = path.join(modulesRoot, 'entities.generated.ts')

function toVar(s: string) {
  return s.replace(/[^a-zA-Z0-9_]/g, '_')
}

function scan() {
  const entries = fs.readdirSync(modulesRoot, { withFileTypes: true })
  const mods = entries.filter(e => e.isDirectory() && !e.name.startsWith('.'))
  const imports: string[] = []
  const entityRefs: string[] = []
  let n = 0
  for (const mod of mods) {
    const modId = mod.name
    const dataDir = path.join(modulesRoot, modId, 'data')
    const dbDir = path.join(modulesRoot, modId, 'db') // legacy fallback
    const baseDir = fs.existsSync(dataDir) ? dataDir : (fs.existsSync(dbDir) ? dbDir : null)
    if (!baseDir) continue
    // prefer override, then entities.ts, then schema.ts for compatibility
    const candidates = ['entities.override.ts', 'entities.ts', 'schema.ts']
    const found = candidates.map(f => path.join(baseDir, f)).find(p => fs.existsSync(p))
    if (!found) continue
    const importName = `E_${toVar(modId)}_${n++}`
    const sub = path.basename(path.dirname(found)) // 'data' or 'db'
    const relImport = `@/modules/${modId}/${sub}/${path.basename(found).replace(/\.ts$/, '')}`
    imports.push(`import * as ${importName} from '${relImport}'`)
    entityRefs.push(`...Object.values(${importName}).filter(v => typeof v === 'function') as any[]`)
  }
  const output = `// AUTO-GENERATED by scripts/generate-module-entities.ts
${imports.join('\n')}

export const entities = [
  ${entityRefs.join(',\n  ')}
]
`
  fs.writeFileSync(outFile, output)
}

scan()
console.log('Generated', path.relative(process.cwd(), outFile))
